# Advent of Code 2022 - 12

```elixir
Mix.install([
  {:kino, "~> 0.7.0"},
  {:libgraph, "~> 0.16.0"}
])
```

## Input

```elixir
input = Kino.Input.textarea("Input")
```

```elixir
grid =
  Kino.Input.read(input)
  |> String.split("\n", trim: true)
  |> Stream.with_index()
  |> Enum.flat_map(fn {line, y} ->
    line
    |> String.to_charlist()
    |> Stream.with_index()
    |> Enum.map(fn {char, x} ->
      case char do
        ?S -> {{x, y}, 0, :start}
        ?E -> {{x, y}, 25, :end}
        _ -> {{x, y}, char - ?a, nil}
      end
    end)
  end)
```

```elixir
[start, destination] =
  grid
  |> Enum.min_max_by(fn {_, _, type} ->
    case type do
      :start -> -1
      :end -> 1
      _ -> 0
    end
  end)
  |> Tuple.to_list()
  |> Enum.map(&elem(&1, 0))
```

```elixir
vertices =
  grid
  |> Stream.map(fn {pos, height, _} -> {pos, height} end)
  |> Map.new()
```

```elixir
defmodule Pathfinding do
  defp manhattan({x2, y2}) do
    fn {x1, y1} -> abs(x2 - x1) + abs(y2 - y1) end
  end

  def new_graph(edges),
    do:
      Graph.new(type: :directed)
      |> Graph.add_edges(edges)

  def shortest_distance(graph, start, destination) do
    path =
      graph
      |> Graph.a_star(start, destination, manhattan(destination))

    case path do
      nil ->
        nil

      _ ->
        path
        |> Stream.drop(1)
        |> Enum.count()
    end
  end
end
```

```elixir
node_edges = fn {{x, y} = from, height} ->
  edges_to = fn to ->
    case Map.get(vertices, to) do
      nil ->
        []

      z ->
        [
          {{from, to}, max(z - height, 1)},
          {{to, from}, max(height - z, 1)}
        ]
    end
  end

  edges_to.({x + 1, y}) ++ edges_to.({x, y + 1})
end

graph =
  vertices
  |> Stream.flat_map(node_edges)
  |> Stream.filter(fn {_, delta} -> delta == 1 end)
  |> Stream.map(&elem(&1, 0))
  |> Pathfinding.new_graph()
```

## Part 1

```elixir
Pathfinding.shortest_distance(graph, start, destination)
```

## Part 2

```elixir
start_candidates =
  vertices
  |> Stream.filter(fn {_, height} -> height == 0 end)
  |> Enum.map(&elem(&1, 0))
```

This is very slow

```elixir
start_candidates
|> Stream.map(fn start -> Pathfinding.shortest_distance(graph, start, destination) end)
|> Enum.min()
```
